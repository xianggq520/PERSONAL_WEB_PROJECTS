#############################输入输出重定向

#输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中

#输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式

#标准输入重定向（STDIN，文件描述符为 0）：默认从键盘输入，也可从其他文件或命令中输入。
#标准输出重定向（STDOUT，文件描述符为 1）：默认输出到屏幕。
#错误输出重定向（STDERR，文件描述符为 2）：默认输出到屏幕。

# 输入重定向中用到的符号及其作用

命令 < 文件 将文件作为命令的标准输入
命令 << 分界符 从标准输入中读入，直到遇见分界符才停止
命令 < 文件 1 > 文件 2 将文件 1 作为命令的标准输入并将标准输出到文件 2

# 输出重定向中用到的符号及其作用

命令 > 文件 将标准输出重定向到一个文件中（清空原有文件的数据）
命令 2> 文件 将错误输出重定向到一个文件中（清空原有文件的数据）
命令 >> 文件 将标准输出重定向到一个文件中（追加到原有内容的后面）
命令 2>> 文件 将错误输出重定向到一个文件中（追加到原有内容的后面）
命令 >> 文件 2>&1 或 命令 &>> 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）


############################# 管道命令符

# 管道命令符，把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入


[root@linuxprobe ~]# grep "/sbin/nologin" /etc/passwd | wc -l


[root@linuxprobe ~]# echo "Content" | mail -s "Subject" linuxprobe


[root@linuxprobe ~]# mail -s "Readme" root@linuxprobe.com << over


############################# 命令行的通配符

顾名思义，通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，
问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配 0～9 之间的单个数字的字符，
而中括号内加上字母[abc]则是代表匹配 a、b、c 三个字符中的任意一个字符

[root@linuxprobe ~]# ls -l /dev/sda*

[root@linuxprobe ~]# ls -l /dev/sda?

[root@linuxprobe ~]# ls -l /dev/sda[0-9]

[root@linuxprobe ~]# ls -l /dev/sda[135]

############################# 常用的转义字符


4 个最常用的转义字符如下所示。

反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。
单引号（''）：转义其中所有的变量为单纯的字符串。
双引号（""）：保留其中的变量属性，不进行转义处理。
反引号（``）：把其中的命令执行后返回结果。


[root@localhost temp]# price=5
[root@localhost temp]# echo "price is $price"
price is 5
[root@localhost temp]# echo "price is \$$price"
price is $5
[root@localhost temp]# echo `uname -a`
Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux
[root@localhost temp]# echo 'price is $price'
price is $price


############################# 重要的环境变量

命令在 Linux 中的执行分为 4 个步骤
1.判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果，话则直接执行

2.Linux 系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称

3.Bash 解释器判断用户输入的是内部命令还是外部命令。

4.系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作 PATH，可
以简单地把它理解成是“解释器的小助手”，作用是告诉 Bash 解释器待执行的命令可能存放
的位置，然后 Bash 解释器就会乖乖地在这些位置中逐个查找

# 不能将当前目录（.）添加到 PATH 中

这里有比较经典的问题：“为什么不能将当前目录（.）添加到 PATH 中呢? ” 原因是，
尽管可以将当前目录（.）添加到 PATH 变量中，从而在某些情况下可以让用户免去输入命令
所在路径的麻烦。但是，如果黑客在比较常用的公共目录/tmp 中存放了一个与 ls 或 cd 命令同
名的木马文件，而用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了。

[root@localhost temp]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

#定义变量  [root@linuxprobe ~]# WORKDIR=/home/workdir

#提升为全局变量 [root@linuxprobe ~]# export WORKDIR








